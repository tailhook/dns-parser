use Error;

// see https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-10

#[derive(Debug, Clone, Copy)]
pub struct Record<'a> {
    // TODO: we are not actually parsing the contents of the HTTPS RR for now
    pub raw: &'a [u8],
}

impl<'a> super::Record<'a> for Record<'a> {
    const TYPE: isize = 65;

    fn parse(rdata: &'a [u8], _original: &'a [u8]) -> super::RDataResult<'a> {
        if rdata.len() < 1 {
            return Err(Error::WrongRdataLength);
        }
        let record = Record { raw: rdata };
        Ok(super::RData::HTTPS(record))
    }
}

#[cfg(test)]
mod test {
    use Opcode::*;
    use QueryClass as QC;
    use QueryType as QT;
    use ResponseCode::NoError;

    use crate::RData;
    use {Header, Packet};

    #[test]
    fn parse_response() {
        // from wireshark
        let response: [u8; 215] = [
            0x21, 0x8b, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x06, 0x6d,
            0x6f, 0x62, 0x69, 0x6c, 0x65, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x04, 0x64,
            0x61, 0x74, 0x61, 0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03,
            0x63, 0x6f, 0x6d, 0x00, 0x00, 0x41, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x6d, 0x00, 0x27, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x06,
            0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x04, 0x64, 0x61, 0x74, 0x61, 0x0e, 0x74, 0x72,
            0x61, 0x66, 0x66, 0x69, 0x63, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x03, 0x6e,
            0x65, 0x74, 0x00, 0xc0, 0x3e, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00,
            0x29, 0x10, 0x6f, 0x6e, 0x65, 0x64, 0x73, 0x63, 0x6f, 0x6c, 0x70, 0x72, 0x64, 0x65,
            0x75, 0x73, 0x30, 0x37, 0x06, 0x65, 0x61, 0x73, 0x74, 0x75, 0x73, 0x08, 0x63, 0x6c,
            0x6f, 0x75, 0x64, 0x61, 0x70, 0x70, 0x05, 0x61, 0x7a, 0x75, 0x72, 0x65, 0xc0, 0x29,
            0xc0, 0x82, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x31, 0x07, 0x6e,
            0x73, 0x31, 0x2d, 0x32, 0x30, 0x31, 0x09, 0x61, 0x7a, 0x75, 0x72, 0x65, 0x2d, 0x64,
            0x6e, 0x73, 0xc0, 0x29, 0x06, 0x6d, 0x73, 0x6e, 0x68, 0x73, 0x74, 0xc0, 0x1f, 0x00,
            0x00, 0x27, 0x11, 0x00, 0x00, 0x03, 0x84, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x09, 0x3a,
            0x80, 0x00, 0x00, 0x00, 0x3c,
        ];

        let packet = Packet::parse(&response).unwrap();
        assert_eq!(
            packet.header,
            Header {
                id: 0x218b,
                query: false,
                opcode: StandardQuery,
                authoritative: false,
                truncated: false,
                recursion_desired: true,
                recursion_available: true,
                authenticated_data: false,
                checking_disabled: false,
                response_code: NoError,
                questions: 1,
                answers: 2,
                nameservers: 1,
                additional: 0,
            }
        );
        assert_eq!(packet.questions.len(), 1);
        assert_eq!(packet.questions[0].qtype, QT::HTTPS);
        assert_eq!(packet.questions[0].qclass, QC::IN);
        assert_eq!(
            &packet.questions[0].qname.to_string()[..],
            "mobile.events.data.microsoft.com"
        );
    }

    #[test]
    fn parse_foo() {
        let response = [
            0x6c, 0x78, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x03, 0x77,
            0x77, 0x77, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00,
            0x00, 0x41, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x41, 0x00, 0x01, 0x00, 0x00, 0x50, 0xce,
            0x00, 0x0d, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x06, 0x02, 0x68, 0x32, 0x02, 0x68,
            0x33, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x04, 0x8e,
            0xfb, 0x10, 0x69, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00,
            0x04, 0x8e, 0xfb, 0x10, 0x67, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
            0xc3, 0x00, 0x04, 0x8e, 0xfb, 0x10, 0x6a, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
            0x00, 0x00, 0xc3, 0x00, 0x04, 0x8e, 0xfb, 0x10, 0x68, 0xc0, 0x0c, 0x00, 0x01, 0x00,
            0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x04, 0x8e, 0xfb, 0x10, 0x63, 0xc0, 0x0c, 0x00,
            0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x04, 0x8e, 0xfb, 0x10, 0x93, 0xc0,
            0x0c, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x10, 0x26, 0x07, 0xf8,
            0xb0, 0x40, 0x04, 0x0c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0xc0,
            0x0c, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x10, 0x26, 0x07, 0xf8,
            0xb0, 0x40, 0x04, 0x0c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xc0,
            0x0c, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x10, 0x26, 0x07, 0xf8,
            0xb0, 0x40, 0x04, 0x0c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x93, 0xc0,
            0x0c, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x10, 0x26, 0x07, 0xf8,
            0xb0, 0x40, 0x04, 0x0c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67,
        ];

        let packet = Packet::parse(&response).unwrap();
        println!("{:#?}", packet);
        assert_eq!(
            packet.header,
            Header {
                id: 27768,
                query: false,
                opcode: StandardQuery,
                authoritative: false,
                truncated: false,
                recursion_desired: true,
                recursion_available: true,
                authenticated_data: false,
                checking_disabled: false,
                response_code: NoError,
                questions: 1,
                answers: 1,
                nameservers: 0,
                additional: 10,
            }
        );
        assert_eq!(packet.questions.len(), 1);
        assert_eq!(packet.questions[0].qtype, QT::HTTPS);
        assert_eq!(packet.questions[0].qclass, QC::IN);
        assert_eq!(&packet.questions[0].qname.to_string()[..], "www.google.com");
        assert_eq!(packet.answers.len(), 1);
        let https_ans = &packet.answers[0];
        match &https_ans.data {
            RData::HTTPS(rec) => {
                assert_eq!(rec.raw, [0, 1, 0, 0, 1, 0, 6, 2, 104, 50, 2, 104, 51]);
            }
            x => panic!("Expected HTTPS type, got {:?}", x),
        }
    }
}
