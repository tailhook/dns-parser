use Error;

#[derive(Debug, Clone, Copy)]
pub struct Record<'a> {
    // TODO: we are not actually parsing the contents of the HTTPS RR for now
    pub raw: &'a [u8],
}

impl<'a> super::Record<'a> for Record<'a> {
    const TYPE: isize = 64;

    fn parse(rdata: &'a [u8], _original: &'a [u8]) -> super::RDataResult<'a> {
        if rdata.len() < 1 {
            return Err(Error::WrongRdataLength);
        }
        let record = Record { raw: rdata };
        Ok(super::RData::SVCB(record))
    }
}

#[cfg(test)]
mod test {
    use Opcode::*;
    use QueryClass as QC;
    use QueryType as QT;
    use ResponseCode::NoError;

    use crate::RData;
    use {Header, Packet};

    #[test]
    fn parse_request() {
        // from wireshark
        let response: [u8; 36] = [
            0x47, 0xaf, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x04, 0x5f, 0x64, 0x6e, 
			0x73, 0x08, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 
			0x65, 0x72, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00, 
			0x00, 0x40, 0x00, 0x01
        ];

        let packet = Packet::parse(&response).unwrap();
        assert_eq!(
            packet.header,
            Header {
                id: 18351,
                query: true,
                opcode: StandardQuery,
                authoritative: false,
                truncated: false,
                recursion_desired: true,
                recursion_available: false,
                authenticated_data: false,
                checking_disabled: false,
                response_code: NoError,
                questions: 1,
                answers: 0,
                nameservers: 0,
                additional: 0,
            }
        );
        assert_eq!(packet.questions.len(), 1);
        assert_eq!(packet.questions[0].qtype, QT::SVCB);
        assert_eq!(packet.questions[0].qclass, QC::IN);
        assert_eq!(
            &packet.questions[0].qname.to_string()[..],
            "_dns.resolver.arpa"
        );
    }

    #[test]
    fn parse_response() {
        let response: [u8; 347] = [
			0x31, 0x3b, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x04, 0x04, 0x5f, 0x64, 0x6e,
			0x73, 0x08, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76,
			0x65, 0x72, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00,
			0x00, 0x40, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x40,
			0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x67,
			0x00, 0x01, 0x03, 0x6f, 0x6e, 0x65, 0x03, 0x6f,
			0x6e, 0x65, 0x03, 0x6f, 0x6e, 0x65, 0x03, 0x6f,
			0x6e, 0x65, 0x00, 0x00, 0x01, 0x00, 0x06, 0x02,
			0x68, 0x32, 0x02, 0x68, 0x33, 0x00, 0x03, 0x00,
			0x02, 0x01, 0xbb, 0x00, 0x04, 0x00, 0x08, 0x01,
			0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00,
			0x06, 0x00, 0x20, 0x26, 0x06, 0x47, 0x00, 0x47,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x11, 0x11, 0x26, 0x06, 0x47, 0x00, 0x47,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x10, 0x01, 0x00, 0x07, 0x00, 0x10, 0x2f,
			0x64, 0x6e, 0x73, 0x2d, 0x71, 0x75, 0x65, 0x72,
			0x79, 0x7b, 0x3f, 0x64, 0x6e, 0x73, 0x7d, 0xc0,
			0x0c, 0x00, 0x40, 0x00, 0x01, 0x00, 0x00, 0x01,
			0x2c, 0x00, 0x51, 0x00, 0x02, 0x03, 0x6f, 0x6e,
			0x65, 0x03, 0x6f, 0x6e, 0x65, 0x03, 0x6f, 0x6e,
			0x65, 0x03, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x01,
			0x00, 0x04, 0x03, 0x64, 0x6f, 0x74, 0x00, 0x03,
			0x00, 0x02, 0x03, 0x55, 0x00, 0x04, 0x00, 0x08,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01,
			0x00, 0x06, 0x00, 0x20, 0x26, 0x06, 0x47, 0x00,
			0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x11, 0x11, 0x26, 0x06, 0x47, 0x00,
			0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x10, 0x01, 0x03, 0x6f, 0x6e, 0x65,
			0x03, 0x6f, 0x6e, 0x65, 0x03, 0x6f, 0x6e, 0x65,
			0x03, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x1c, 0x00,
			0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x10, 0x26,
			0x06, 0x47, 0x00, 0x47, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0xc0,
			0xf4, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x01,
			0x2c, 0x00, 0x10, 0x26, 0x06, 0x47, 0x00, 0x47,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x10, 0x01, 0xc0, 0xf4, 0x00, 0x01, 0x00,
			0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x04, 0x01,
			0x01, 0x01, 0x01, 0xc0, 0xf4, 0x00, 0x01, 0x00,
			0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x04, 0x01,
			0x00, 0x00, 0x01
        ];

        let packet = Packet::parse(&response).unwrap();
        assert_eq!(
            packet.header,
            Header {
                id: 12603,
                query: false,
                opcode: StandardQuery,
                authoritative: false,
                truncated: false,
                recursion_desired: true,
                recursion_available: true,
                authenticated_data: false,
                checking_disabled: false,
                response_code: NoError,
                questions: 1,
                answers: 2,
                nameservers: 0,
                additional: 4,
            }
        );
        assert_eq!(packet.questions.len(), 1);
        assert_eq!(packet.questions[0].qtype, QT::SVCB);
        assert_eq!(packet.questions[0].qclass, QC::IN);
        assert_eq!(
            &packet.questions[0].qname.to_string()[..],
            "_dns.resolver.arpa"
        );
        let https_ans = &packet.answers[0];
        match &https_ans.data {
            RData::SVCB(rec) => {
                assert_eq!(rec.raw.len(), 103);
            }
            x => panic!("Expected SVCB type, got {:?}", x),
        }
    }
}
