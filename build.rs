use std::{env, fs};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::collections::HashSet;

fn main() {
    let root_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let rdata_dir = format!("{}/src/rdata", root_dir);
    let entries = fs::read_dir(&rdata_dir).unwrap();

    let qtype_only = {
        let types = vec!["AXFR", "MAILA", "MAILB", "ALL"];
        let mut set = HashSet::new();
        for t in types {
            set.insert(t);
        }
        set
    };

    let mut imports = String::new();

    let mut typ = format!(r#"
        /// The TYPE value according to RFC 1035
        #[derive(Debug, PartialEq, Eq, Clone, Copy)]
        pub enum Type {{
    "#);

    let mut typ_impl = format!(r#"
        impl Type {{
            /// Parse a type code
            pub fn parse(code: u16) -> Result<Type, Error> {{
                use self::Type::*;
                match code as isize {{
    "#);

    let mut qtyp = format!(r#"
        /// The QTYPE value according to RFC 1035
        #[derive(Debug, PartialEq, Eq, Clone, Copy)]
        pub enum QueryType {{
    "#);

    let mut qtyp_impl = format!(r#"
        impl QueryType {{
            /// Parse a query type code
            pub fn parse(code: u16) -> Result<QueryType, Error> {{
                use self::QueryType::*;
                match code as isize {{
    "#);

    let mut rdata_impl = format!(r#"
        impl<'a> RData<'a> {{
            /// Parse an RR data and return RData enumeration
            pub fn parse(typ: Type, rdata: &'a [u8], original: &'a [u8]) -> RDataResult<'a> {{
                match typ {{
    "#);

    for entry in entries {
        let path = entry.unwrap();
        if path.file_type().unwrap().is_file() {
            let file_name = path.file_name().into_string().unwrap();
            if file_name.ends_with(".rs") && file_name != "mod.rs" && file_name != "config.rs" {
                let lower = file_name.trim_right_matches(".rs");
                let upper = lower.to_uppercase();
                let title = {
                    let (a, o) = lower.split_at(1);
                    format!("{}{}", a.to_uppercase(), o)
                };

                imports.push_str(&format!("pub mod {0}; pub use self::{0}::Record as {1};\n", lower, title));

                let type_variant = format!("{} = {}::Record::TYPE,\n", upper, lower);
                let code_to_type = format!("{}::Record::TYPE => Ok({}),\n", lower, upper);
                if !qtype_only.contains(upper.as_str()) {
                    let typ_to_rdata = format!("Type::{} => {}::parse(rdata, original),\n", upper, title);
                    typ.push_str(&type_variant);
                    typ_impl.push_str(&code_to_type);
                    rdata_impl.push_str(&typ_to_rdata);
                }
                qtyp.push_str(&type_variant);
                qtyp_impl.push_str(&code_to_type);
            }
        }
    }

    typ.push('}');
    qtyp.push('}');

    typ_impl.push_str(&format!(r#"
                    x => Err(Error::InvalidType(x as u16)),
                }}
            }}
        }}
    "#));
    qtyp_impl.push_str(&format!(r#"
                    x => Err(Error::InvalidQueryType(x as u16)),
                }}
            }}
        }}
    "#));

    rdata_impl.push_str(&format!(r#"
                }}
            }}
        }}
    "#));

    imports.push_str(&format!(r#"
        mod config;

        pub use self::config::RData;

        use Error;
    "#));

    let dest_path = Path::new(&rdata_dir).join("mod.rs");
    let mut f = File::create(&dest_path).unwrap();

    let code = format!(r#"
        // Auto generated file. Do not edit.
        // 
        // This file is generated by the build script.
        // Any changes you make here will be overwritten.
        {}
        pub type RDataResult<'a> = Result<RData<'a>, Error>;

        pub (crate) trait Record<'a> {{
            const TYPE: isize;

            fn parse(rdata: &'a [u8], original: &'a [u8]) -> RDataResult<'a>;
        }}
        {}{}{}{}{}
    "#, imports, typ, typ_impl, qtyp, qtyp_impl, rdata_impl);
    f.write_all(code.as_bytes()).unwrap();
}
